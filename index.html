<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>捕食と逃避行動する昆虫型捕食者と被捕食者</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      class Creature {
        constructor(isHunter = false) {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.radius = isHunter ? 12.5 : 5;
          this.baseSpeed = isHunter ? 2 : 0.75;
          this.speed = this.baseSpeed;
          this.dx = 0;
          this.dy = 0;
          this.color = isHunter
            ? "#8B4513"
            : `rgb(${Math.random() * 255},${Math.random() * 255},${
                Math.random() * 255
              })`;
          this.isHunter = isHunter;
          this.angle = 0;
          this.alive = true;
          this.searchRadius = isHunter ? this.radius * 10 : this.radius * 20;
          this.movementTimer = 0;
          this.isMoving = false;
          if (isHunter) {
            this.eatenCount = 0;
          }
        }

        draw() {
          if (!this.alive) return;

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);

          if (this.isHunter) {
            // 胴体 (楕円)
            ctx.beginPath();
            ctx.ellipse(0, 0, this.radius * 2, this.radius, 0, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();

            // 頭 (三角形)
            ctx.beginPath();
            ctx.moveTo(this.radius * 2, 0);
            ctx.lineTo(this.radius * 2.5, -this.radius / 2);
            ctx.lineTo(this.radius * 2.5, this.radius / 2);
            ctx.closePath();
            ctx.fillStyle = "#000000";
            ctx.fill();

            // 足 (線)
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            for (let i = -1; i <= 1; i += 0.5) {
              ctx.beginPath();
              ctx.moveTo(this.radius * i, -this.radius);
              ctx.lineTo(this.radius * i, -this.radius * 1.5);
              ctx.moveTo(this.radius * i, this.radius);
              ctx.lineTo(this.radius * i, this.radius * 1.5);
              ctx.stroke();
            }

            // 触覚
            ctx.beginPath();
            ctx.moveTo(this.radius * 2, -this.radius / 4);
            ctx.lineTo(this.radius * 2.5, -this.radius);
            ctx.moveTo(this.radius * 2, this.radius / 4);
            ctx.lineTo(this.radius * 2.5, this.radius);
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
          }

          // 索敵範囲を表示
          //   ctx.beginPath();
          //   ctx.arc(0, 0, this.searchRadius, 0, Math.PI * 2);
          //   ctx.strokeStyle = this.isHunter
          //     ? "rgba(255, 0, 0, 0.2)"
          //     : "rgba(0, 255, 0, 0.2)";
          //   ctx.stroke();

          ctx.restore();
        }

        update(creatures, feces) {
          if (!this.alive) return;

          let closestTarget = null;
          let closestTargetDistance = Infinity;

          const targets = this.isHunter
            ? creatures.filter(
                (c) => !c.isHunter && this.radius * 0.7 > c.radius
              )
            : feces;

          targets.forEach((target) => {
            if ((target !== this && target.alive) || !this.isHunter) {
              const distance = Math.hypot(target.x - this.x, target.y - this.y);
              if (
                distance < this.searchRadius &&
                distance < closestTargetDistance
              ) {
                closestTargetDistance = distance;
                closestTarget = target;
              }
            }
          });

          if (closestTarget) {
            const angle = Math.atan2(
              closestTarget.y - this.y,
              closestTarget.x - this.x
            );
            this.dx = Math.cos(angle) * this.speed;
            this.dy = Math.sin(angle) * this.speed;
            this.isMoving = true;
          } else {
            this.movementTimer--;
            if (this.movementTimer <= 0) {
              this.isMoving = Math.random() < 0.5;
              if (this.isMoving) {
                const angle = Math.random() * Math.PI * 2;
                this.dx = Math.cos(angle) * this.speed;
                this.dy = Math.sin(angle) * this.speed;
              } else {
                this.dx = 0;
                this.dy = 0;
              }
              this.movementTimer = Math.floor(Math.random() * 60) + 30;
            }
          }

          if (this.isMoving) {
            this.x += this.dx;
            this.y += this.dy;
            this.angle = Math.atan2(this.dy, this.dx);
          }

          // 画面の端での跳ね返り
          if (this.x + this.radius > canvas.width) {
            this.x = canvas.width - this.radius;
            this.dx = -Math.abs(this.dx);
          } else if (this.x - this.radius < 0) {
            this.x = this.radius;
            this.dx = Math.abs(this.dx);
          }

          if (this.y + this.radius > canvas.height) {
            this.y = canvas.height - this.radius;
            this.dy = -Math.abs(this.dy);
          } else if (this.y - this.radius < 0) {
            this.y = this.radius;
            this.dy = Math.abs(this.dy);
          }

          // 捕食・成長処理
          if (
            closestTarget &&
            closestTargetDistance <
              this.radius +
                (this.isHunter ? closestTarget.radius : closestTarget.radius)
          ) {
            if (this.isHunter) {
              closestTarget.alive = false;
              this.eatenCount++;
              if (this.eatenCount % 10 === 0) {
                feces.push(new Feces(this.x, this.y));
              }
            } else {
              feces.splice(feces.indexOf(closestTarget), 1);
              this.radius += 0.5;
            }
          }

          this.draw();
        }
      }

      class Feces {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.radius = 3;
          this.color = "#8B4513";
        }

        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
        }
      }

      let creatures = [
        // new Creature(true), // 捕食者1
        // new Creature(true), // 捕食者2
        // new Creature(true), // 捕食者2
        // new Creature(true), // 捕食者2
        // new Creature(true), // 捕食者2
        ...Array.from({ length: 5 }, () => new Creature(true)), // 被捕食者
        ...Array.from({ length: 30000 }, () => new Creature()), // 被捕食者
      ];

      let feces = [];

      function addNewPrey() {
        creatures.push(new Creature());
      }

      setInterval(addNewPrey, 100); // 1秒ごとに新しい被捕食者を追加

      function animate() {
        requestAnimationFrame(animate);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        creatures.forEach((creature) => creature.update(creatures, feces));
        feces.forEach((fece) => fece.draw());

        // 死んだ生物を配列から削除
        creatures = creatures.filter((creature) => creature.alive);
      }

      animate();

      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    </script>
  </body>
</html>
