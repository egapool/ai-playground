<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>捕食と逃避行動する昆虫型捕食者と被捕食者</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      class Creature {
        constructor(isHunter = false) {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.radius = isHunter ? 12.5 : 5;
          this.baseSpeed = isHunter ? 2 : 1;
          this.speed = this.baseSpeed;
          this.dx = 0;
          this.dy = 0;
          this.color = isHunter
            ? "#8B4513"
            : `rgb(${Math.random() * 255},${Math.random() * 255},${
                Math.random() * 255
              })`;
          this.isHunter = isHunter;
          this.angle = 0;
          this.alive = true;
          this.searchRadius = isHunter ? this.radius * 10 : this.radius * 20;
          this.movementTimer = 0;
          this.isMoving = false;
          if (isHunter) {
            this.eatenCount = 0;
          }
        }

        draw() {
          if (!this.alive) return;

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);

          if (this.isHunter) {
            // 胴体 (楕円)
            ctx.beginPath();
            ctx.ellipse(0, 0, this.radius * 2, this.radius, 0, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();

            // 頭 (三角形)
            ctx.beginPath();
            ctx.moveTo(this.radius * 2, 0);
            ctx.lineTo(this.radius * 2.5, -this.radius / 2);
            ctx.lineTo(this.radius * 2.5, this.radius / 2);
            ctx.closePath();
            ctx.fillStyle = "#000000";
            ctx.fill();

            // 足 (線)
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            for (let i = -1; i <= 1; i += 0.5) {
              ctx.beginPath();
              ctx.moveTo(this.radius * i, -this.radius);
              ctx.lineTo(this.radius * i, -this.radius * 1.5);
              ctx.moveTo(this.radius * i, this.radius);
              ctx.lineTo(this.radius * i, this.radius * 1.5);
              ctx.stroke();
            }

            // 触覚
            ctx.beginPath();
            ctx.moveTo(this.radius * 2, -this.radius / 4);
            ctx.lineTo(this.radius * 2.5, -this.radius);
            ctx.moveTo(this.radius * 2, this.radius / 4);
            ctx.lineTo(this.radius * 2.5, this.radius);
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
          }

          ctx.restore();
        }

        update(creatures, feces) {
          if (!this.alive) return;

          let closestTarget = null;
          let closestTargetDistance = Infinity;
          let closestHunter = null;
          let closestHunterDistance = Infinity;
          let closestFeces = null;
          let closestFecesDistance = Infinity;

          const targets = this.isHunter
            ? creatures.filter(
                (c) => !c.isHunter && this.radius * 0.7 > c.radius
              )
            : feces;

          creatures.forEach((creature) => {
            if (creature !== this && creature.alive) {
              const distance = Math.hypot(
                creature.x - this.x,
                creature.y - this.y
              );
              if (this.isHunter && !creature.isHunter) {
                if (
                  distance < this.searchRadius &&
                  distance < closestTargetDistance
                ) {
                  closestTargetDistance = distance;
                  closestTarget = creature;
                }
              } else if (!this.isHunter && creature.isHunter) {
                if (
                  distance < this.searchRadius &&
                  distance < closestHunterDistance
                ) {
                  closestHunterDistance = distance;
                  closestHunter = creature;
                }
              }
            }
          });

          if (!this.isHunter) {
            feces.forEach((feces) => {
              const distance = Math.hypot(feces.x - this.x, feces.y - this.y);
              if (
                distance < this.searchRadius &&
                distance < closestFecesDistance
              ) {
                closestFecesDistance = distance;
                closestFeces = feces;
              }
            });
          }

          if (this.isHunter && closestTarget) {
            const angle = Math.atan2(
              closestTarget.y - this.y,
              closestTarget.x - this.x
            );
            this.dx = Math.cos(angle) * this.speed;
            this.dy = Math.sin(angle) * this.speed;
            this.isMoving = true;
          } else if (!this.isHunter) {
            if (closestHunter) {
              // 捕食者がいる場合は逃げる（最優先）
              const angle = Math.atan2(
                this.y - closestHunter.y,
                this.x - closestHunter.x
              );
              this.dx = Math.cos(angle) * this.speed * 1.2; // 逃げる速度を少し上げる
              this.dy = Math.sin(angle) * this.speed * 1.2;
              this.isMoving = true;
            } else if (closestFeces) {
              // 捕食者がいない場合は糞を追跡
              const angle = Math.atan2(
                closestFeces.y - this.y,
                closestFeces.x - this.x
              );
              this.dx = Math.cos(angle) * this.speed;
              this.dy = Math.sin(angle) * this.speed;
              this.isMoving = true;
            } else {
              // 何もない場合はランダムに移動
              this.movementTimer--;
              if (this.movementTimer <= 0) {
                this.isMoving = Math.random() < 0.5;
                if (this.isMoving) {
                  const angle = Math.random() * Math.PI * 2;
                  this.dx = Math.cos(angle) * this.speed;
                  this.dy = Math.sin(angle) * this.speed;
                } else {
                  this.dx = 0;
                  this.dy = 0;
                }
                this.movementTimer = Math.floor(Math.random() * 60) + 30;
              }
            }
          } else {
            // 捕食者で目標がない場合
            this.movementTimer--;
            if (this.movementTimer <= 0) {
              this.isMoving = Math.random() < 0.5;
              if (this.isMoving) {
                const angle = Math.random() * Math.PI * 2;
                this.dx = Math.cos(angle) * this.speed;
                this.dy = Math.sin(angle) * this.speed;
              } else {
                this.dx = 0;
                this.dy = 0;
              }
              this.movementTimer = Math.floor(Math.random() * 60) + 30;
            }
          }

          if (this.isMoving) {
            this.x += this.dx;
            this.y += this.dy;
            this.angle = Math.atan2(this.dy, this.dx);
          }

          // 画面の端での跳ね返り
          if (this.x + this.radius > canvas.width) {
            this.x = canvas.width - this.radius;
            this.dx = -Math.abs(this.dx);
          } else if (this.x - this.radius < 0) {
            this.x = this.radius;
            this.dx = Math.abs(this.dx);
          }

          if (this.y + this.radius > canvas.height) {
            this.y = canvas.height - this.radius;
            this.dy = -Math.abs(this.dy);
          } else if (this.y - this.radius < 0) {
            this.y = this.radius;
            this.dy = Math.abs(this.dy);
          }

          // 捕食・成長処理
          if (
            this.isHunter &&
            closestTarget &&
            closestTargetDistance < this.radius + closestTarget.radius
          ) {
            closestTarget.alive = false;
            this.eatenCount++;
            if (this.eatenCount % 10 === 0) {
              feces.push(new Feces(this.x, this.y));
            }
          } else if (
            !this.isHunter &&
            closestFeces &&
            closestFecesDistance < this.radius + closestFeces.radius
          ) {
            const fecesIndex = feces.indexOf(closestFeces);
            if (fecesIndex !== -1) {
              feces.splice(fecesIndex, 1);
              this.radius += 0.5;
            }
          }

          this.draw();
        }
      }

      class Feces {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.radius = 3;
          this.color = "#8B4513";
        }

        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
        }
      }

      let creatures = [
        ...Array.from({ length: 5 }, () => new Creature(true)), // 捕食者
        ...Array.from({ length: 300 }, () => new Creature()), // 被捕食者
      ];

      let feces = [];

      function addNewPrey() {
        creatures.push(new Creature());
      }

      function addNewHunter() {
        creatures.push(new Creature(true));
      }

      setInterval(addNewPrey, 1000); // 1秒ごとに新しい被捕食者を追加

      function animate() {
        requestAnimationFrame(animate);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        creatures.forEach((creature) => creature.update(creatures, feces));
        feces.forEach((fece) => fece.draw());

        // 死んだ生物を配列から削除
        creatures = creatures.filter((creature) => creature.alive);
      }

      animate();

      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });

      // スペースキーで捕食者を追加
      window.addEventListener("keydown", (event) => {
        if (event.code === "Space") {
          addNewHunter();
        }
      });
    </script>
  </body>
</html>
